<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Naval Strike</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #fff;
      overflow: hidden;
    }
    canvas { border: 2px solid #1a3a5c; display: block; }
    .hud {
      width: 800px;
      display: flex;
      justify-content: space-between;
      padding: 8px 4px;
      font-size: 16px;
      color: #4fc3f7;
    }
    .title-text {
      font-size: 28px;
      color: #4fc3f7;
      letter-spacing: 6px;
      margin-bottom: 6px;
      text-shadow: 0 0 15px rgba(79,195,247,0.5);
    }
    .instructions {
      color: #6a8fa8;
      font-size: 13px;
      margin-bottom: 10px;
    }
    .back-link {
      color: #6a8fa8;
      font-size: 13px;
      margin-top: 10px;
      text-decoration: none;
    }
    .back-link:hover { color: #4fc3f7; }

    .settings-btn {
      position: fixed;
      top: 12px;
      right: 16px;
      background: none;
      border: 1px solid #1e3a5f;
      border-radius: 6px;
      color: #4fc3f7;
      font-size: 22px;
      padding: 6px 10px;
      cursor: pointer;
      z-index: 100;
      transition: background 0.2s;
    }
    .settings-btn:hover { background: #0f2040; }

    .settings-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 200;
      align-items: center;
      justify-content: center;
    }
    .settings-overlay.open { display: flex; }

    .settings-panel {
      background: #0f1f35;
      border: 1px solid #1e3a5f;
      border-radius: 10px;
      padding: 28px 36px;
      min-width: 320px;
      color: #c8dce8;
      font-family: 'Courier New', monospace;
    }
    .settings-panel h2 {
      color: #4fc3f7;
      font-size: 22px;
      margin-bottom: 20px;
      letter-spacing: 3px;
    }
    .setting-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .setting-row label { font-size: 14px; }
    .setting-row select {
      background: #0a1628;
      border: 1px solid #1e3a5f;
      border-radius: 4px;
      color: #4fc3f7;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      padding: 6px 10px;
      outline: none;
    }
    .setting-row select:focus { border-color: #4fc3f7; }
    .settings-panel button {
      margin-top: 10px;
      width: 100%;
      background: #1565c0;
      border: none;
      border-radius: 4px;
      color: #fff;
      font-family: 'Courier New', monospace;
      font-size: 15px;
      padding: 10px;
      cursor: pointer;
    }
    .settings-panel button:hover { background: #1e88e5; }
  </style>
</head>
<body>
  <button class="settings-btn" id="settingsBtn" title="Settings">&#9881;</button>

  <div class="settings-overlay" id="settingsOverlay">
    <div class="settings-panel">
      <h2>SETTINGS</h2>
      <div class="setting-row">
        <label>Gun Rounds</label>
        <select id="settingGuns">
          <option value="100">100</option>
          <option value="200" selected>200 (default)</option>
          <option value="300">300</option>
          <option value="500">500</option>
          <option value="infinite">Infinite</option>
        </select>
      </div>
      <div class="setting-row">
        <label>Bombs</label>
        <select id="settingBombs">
          <option value="5">5</option>
          <option value="10" selected>10 (default)</option>
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="infinite">Infinite</option>
        </select>
      </div>
      <button id="settingsClose">APPLY &amp; CLOSE</button>
    </div>
  </div>

  <div class="title-text">NAVAL STRIKE</div>
  <div class="instructions">ARROWS MOVE &nbsp;|&nbsp; SPACE MACHINE GUN &nbsp;|&nbsp; B DROP BOMB &nbsp;|&nbsp; R RESTART &nbsp;|&nbsp; &#9881; SETTINGS</div>
  <div class="hud">
    <span>SCORE: <span id="score">0</span></span>
    <span>GUNS: <span id="guns">200</span></span>
    <span>BOMBS: <span id="bombs">10</span></span>
    <span>LIVES: <span id="lives">&#9829;&#9829;&#9829;</span></span>
    <span>LVL: <span id="level">1</span></span>
    <span>HI: <span id="hiscore">0</span></span>
  </div>
  <canvas id="game" width="800" height="500"></canvas>
  <a class="back-link" href="index.html">&larr; BACK TO MENU</a>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // Constants
    const PLAYER_SPEED = 5;
    const BULLET_SPEED = 10;
    const GUN_COOLDOWN = 6;
    const BOMB_FALL_FRAMES = 45;
    const BOMB_COOLDOWN = 25;
    const BOMB_DRIFT = 90;
    const BOMB_BLAST_R = 35;
    const AA_SPEED = 3;
    const MAX_LIVES = 3;
    const INVINCIBLE_FRAMES = 90;

    const SHIP_CONFIGS = {
      transport:  { len: 50, beam: 14, speed: 0.5, aaRate: 0,  color: '#7a8090', points: 150 },
      destroyer:  { len: 42, beam: 12, speed: 1.0, aaRate: 70, color: '#8a8a94', points: 200 },
      cruiser:    { len: 58, beam: 16, speed: 0.6, aaRate: 50, color: '#6a7a84', points: 300 },
      battleship: { len: 78, beam: 22, speed: 0.35,aaRate: 35, color: '#5a6874', points: 500 }
    };

    // Settings
    let settings = { gunAmmo: 200, bombAmmo: 10 };
    let infiniteGuns = false, infiniteBombs = false;

    // State
    let player, bullets, bombs, enemyShips, enemyPlanes, aaShots, explosions;
    let score, hiScore, level, gameState, gameOverReason;
    let gunAmmo, bombAmmo;
    let gunCooldown, bombCooldown, muzzleFlash;
    let shipsToSpawn, shipsSpawned, shipsDestroyed;
    let shipSpawnTimer, planeSpawnTimer;
    let scrollOffset, screenShake;
    let keys = {};

    // --- Settings ---

    function applySettings() {
      const gv = document.getElementById('settingGuns').value;
      const bv = document.getElementById('settingBombs').value;
      settings.gunAmmo = gv === 'infinite' ? 'infinite' : parseInt(gv, 10);
      settings.bombAmmo = bv === 'infinite' ? 'infinite' : parseInt(bv, 10);
    }

    // --- Init ---

    function init() {
      player = { x: W / 2, y: H - 80, lives: MAX_LIVES, invincible: 0 };
      score = 0;
      level = 1;
      scrollOffset = 0;
      screenShake = 0;
      muzzleFlash = 0;
      gameOverReason = '';
      infiniteGuns = settings.gunAmmo === 'infinite';
      infiniteBombs = settings.bombAmmo === 'infinite';
      gunAmmo = infiniteGuns ? Infinity : settings.gunAmmo;
      bombAmmo = infiniteBombs ? Infinity : settings.bombAmmo;
      gameState = 'playing';
      startLevel();
    }

    function startLevel() {
      bullets = [];
      bombs = [];
      aaShots = [];
      explosions = [];
      enemyShips = [];
      enemyPlanes = [];
      gunCooldown = 0;
      bombCooldown = 0;
      shipsDestroyed = 0;
      shipsSpawned = 0;
      shipsToSpawn = Math.min(2 + level, 10);
      shipSpawnTimer = 60;
      planeSpawnTimer = 100;

      // Bonus ammo on new levels
      if (level > 1) {
        if (!infiniteGuns) gunAmmo += level * 15;
        if (!infiniteBombs) bombAmmo += Math.min(level, 3);
      }
      updateHUD();
    }

    // --- Spawning ---

    function spawnShip() {
      const types = ['transport', 'destroyer', 'cruiser', 'battleship'];
      const weights = [3, 4, 2, Math.max(0, level - 1)];
      if (level >= 2) weights[2] += level - 1;
      const total = weights.reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      let type = 'transport';
      for (let i = 0; i < types.length; i++) {
        r -= weights[i];
        if (r <= 0) { type = types[i]; break; }
      }

      const cfg = SHIP_CONFIGS[type];
      const speedMult = 1 + level * 0.08;
      enemyShips.push({
        x: 60 + Math.random() * (W - 120),
        y: -cfg.len,
        len: cfg.len,
        beam: cfg.beam,
        speed: cfg.speed * speedMult,
        hSpeed: (Math.random() - 0.5) * 0.4,
        aaRate: cfg.aaRate,
        aaTimer: cfg.aaRate > 0 ? Math.floor(Math.random() * cfg.aaRate) : 0,
        color: cfg.color,
        points: cfg.points,
        type: type,
        alive: true
      });
    }

    function spawnEnemyPlane() {
      let x, y, sx, sy;
      const p = Math.random();
      if (p < 0.4) {
        x = 50 + Math.random() * (W - 100);
        y = -20;
        sx = (Math.random() - 0.5) * 2;
        sy = 2.5 + Math.random() * 2 + level * 0.15;
      } else if (p < 0.7) {
        x = -20;
        y = 30 + Math.random() * H * 0.4;
        sx = 3 + Math.random() * 2;
        sy = 0.3 + Math.random() * 0.5;
      } else {
        x = W + 20;
        y = 30 + Math.random() * H * 0.4;
        sx = -(3 + Math.random() * 2);
        sy = 0.3 + Math.random() * 0.5;
      }
      enemyPlanes.push({ x, y, sx, sy, alive: true });
    }

    // --- Actions ---

    function fireGun() {
      if (gameState !== 'playing') return;
      if (!infiniteGuns && gunAmmo <= 0) return;
      if (gunCooldown > 0) return;

      if (!infiniteGuns) gunAmmo--;
      gunCooldown = GUN_COOLDOWN;
      muzzleFlash = 3;

      bullets.push({ x: player.x, y: player.y - 22, dy: -BULLET_SPEED });
      updateHUD();
    }

    function dropBomb() {
      if (gameState !== 'playing') return;
      if (!infiniteBombs && bombAmmo <= 0) return;
      if (bombCooldown > 0) return;

      if (!infiniteBombs) bombAmmo--;
      bombCooldown = BOMB_COOLDOWN;

      bombs.push({
        x: player.x,
        startY: player.y,
        targetY: player.y - BOMB_DRIFT,
        frame: 0,
        totalFrames: BOMB_FALL_FRAMES,
        exploded: false
      });
      updateHUD();
    }

    function fireAA(ship) {
      const dx = player.x - ship.x;
      const dy = player.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 1) return;
      const spread = 0.18;
      const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * spread;
      aaShots.push({
        x: ship.x,
        y: ship.y - ship.len * 0.3,
        dx: Math.cos(angle) * AA_SPEED,
        dy: Math.sin(angle) * AA_SPEED,
        life: 130
      });
    }

    function destroyShip(ship) {
      ship.alive = false;
      shipsDestroyed++;
      score += ship.points;
      explosions.push({
        x: ship.x, y: ship.y,
        frame: 0, duration: 55,
        size: ship.len * 0.6,
        type: 'ship'
      });
    }

    function hitPlayer() {
      player.lives--;
      player.invincible = INVINCIBLE_FRAMES;
      screenShake = 8;
      explosions.push({
        x: player.x, y: player.y,
        frame: 0, duration: 20,
        size: 16,
        type: 'plane'
      });
      if (player.lives <= 0) {
        gameState = 'gameover';
        gameOverReason = 'SHOT DOWN';
        if (score > (hiScore || 0)) hiScore = score;
      }
    }

    // --- Drawing ---

    function drawWater() {
      const grad = ctx.createLinearGradient(0, 0, 0, H);
      grad.addColorStop(0, '#0b3d6b');
      grad.addColorStop(0.5, '#094a78');
      grad.addColorStop(1, '#062d4f');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, W, H);

      // Scrolling wave lines
      for (let layer = 0; layer < 6; layer++) {
        const speed = 0.5 + layer * 0.3;
        const offset = scrollOffset * speed;
        const gap = 30 + layer * 12;
        const alpha = 0.06 + layer * 0.008;
        ctx.strokeStyle = `rgba(100,180,220,${alpha})`;
        ctx.lineWidth = 1;
        for (let baseY = -gap; baseY < H + gap; baseY += gap) {
          const y = ((baseY + offset) % (H + gap * 2)) - gap;
          ctx.beginPath();
          for (let x = 0; x <= W; x += 4) {
            const wy = y + Math.sin((x + layer * 80) * 0.02 + offset * 0.01) * (1.5 + layer * 0.5);
            x === 0 ? ctx.moveTo(x, wy) : ctx.lineTo(x, wy);
          }
          ctx.stroke();
        }
      }

      // Foam dots
      ctx.fillStyle = 'rgba(180,220,240,0.04)';
      for (let i = 0; i < 20; i++) {
        const fx = (i * 137 + scrollOffset * 0.3) % W;
        const fy = ((i * 211 + scrollOffset * 1.2) % (H + 20)) - 10;
        ctx.beginPath();
        ctx.arc(fx, fy, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawPlayerPlane() {
      if (player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0) return;

      const x = player.x, y = player.y;
      ctx.save();
      ctx.translate(x, y);

      // Shadow on water
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.beginPath();
      ctx.ellipse(5, 12, 22, 8, 0.1, 0, Math.PI * 2);
      ctx.fill();

      // Wings
      ctx.fillStyle = '#35753d';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-30, 6);
      ctx.lineTo(-28, 10);
      ctx.lineTo(0, 5);
      ctx.lineTo(28, 10);
      ctx.lineTo(30, 6);
      ctx.closePath();
      ctx.fill();

      // Fuselage
      ctx.fillStyle = '#3d8545';
      ctx.beginPath();
      ctx.moveTo(0, -22);
      ctx.lineTo(5, -14);
      ctx.lineTo(5, 14);
      ctx.lineTo(3, 20);
      ctx.lineTo(-3, 20);
      ctx.lineTo(-5, 14);
      ctx.lineTo(-5, -14);
      ctx.closePath();
      ctx.fill();

      // Tail fins
      ctx.fillStyle = '#35753d';
      ctx.beginPath();
      ctx.moveTo(-3, 15);
      ctx.lineTo(-14, 21);
      ctx.lineTo(-12, 23);
      ctx.lineTo(-3, 19);
      ctx.lineTo(3, 19);
      ctx.lineTo(12, 23);
      ctx.lineTo(14, 21);
      ctx.lineTo(3, 15);
      ctx.closePath();
      ctx.fill();

      // Wing roundels
      ctx.fillStyle = 'rgba(70,130,200,0.6)';
      ctx.beginPath();
      ctx.arc(-18, 7, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(18, 7, 3, 0, Math.PI * 2);
      ctx.fill();

      // Cockpit
      ctx.fillStyle = 'rgba(100,190,255,0.6)';
      ctx.beginPath();
      ctx.ellipse(0, -3, 2.5, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Propeller blur
      ctx.fillStyle = 'rgba(200,200,200,0.3)';
      ctx.beginPath();
      ctx.ellipse(0, -24, 9, 2.5, scrollOffset * 0.8, 0, Math.PI * 2);
      ctx.fill();

      // Muzzle flash
      if (muzzleFlash > 0) {
        ctx.fillStyle = `rgba(255,220,60,${muzzleFlash / 3})`;
        ctx.beginPath();
        ctx.arc(0, -24, 4 + muzzleFlash, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawEnemyPlane(plane) {
      if (!plane.alive) return;
      ctx.save();
      ctx.translate(plane.x, plane.y);
      const angle = Math.atan2(plane.sy, plane.sx) - Math.PI / 2;
      ctx.rotate(angle);

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      ctx.beginPath();
      ctx.ellipse(4, 8, 14, 5, 0.1, 0, Math.PI * 2);
      ctx.fill();

      // Wings
      ctx.fillStyle = '#804040';
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-20, 4);
      ctx.lineTo(-18, 7);
      ctx.lineTo(0, 3);
      ctx.lineTo(18, 7);
      ctx.lineTo(20, 4);
      ctx.closePath();
      ctx.fill();

      // Fuselage
      ctx.fillStyle = '#904848';
      ctx.beginPath();
      ctx.moveTo(0, -14);
      ctx.lineTo(3.5, -8);
      ctx.lineTo(3.5, 10);
      ctx.lineTo(2, 14);
      ctx.lineTo(-2, 14);
      ctx.lineTo(-3.5, 10);
      ctx.lineTo(-3.5, -8);
      ctx.closePath();
      ctx.fill();

      // Tail
      ctx.fillStyle = '#804040';
      ctx.beginPath();
      ctx.moveTo(-8, 12);
      ctx.lineTo(8, 12);
      ctx.lineTo(6, 15);
      ctx.lineTo(-6, 15);
      ctx.closePath();
      ctx.fill();

      // Cockpit
      ctx.fillStyle = 'rgba(200,180,100,0.5)';
      ctx.beginPath();
      ctx.ellipse(0, -1, 2, 4, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function drawShip(ship) {
      if (!ship.alive) return;
      ctx.save();
      ctx.translate(ship.x, ship.y);

      const hw = ship.beam / 2;
      const hl = ship.len / 2;

      // Wake
      ctx.fillStyle = 'rgba(180,220,255,0.1)';
      ctx.beginPath();
      ctx.moveTo(-hw * 0.4, hl);
      ctx.lineTo(-hw - 4, hl + 16 + Math.random() * 3);
      ctx.lineTo(hw + 4, hl + 16 + Math.random() * 3);
      ctx.lineTo(hw * 0.4, hl);
      ctx.closePath();
      ctx.fill();

      // Hull
      ctx.fillStyle = ship.color;
      ctx.beginPath();
      ctx.moveTo(0, -hl);
      ctx.lineTo(hw, -hl * 0.35);
      ctx.lineTo(hw, hl * 0.7);
      ctx.lineTo(hw * 0.5, hl);
      ctx.lineTo(-hw * 0.5, hl);
      ctx.lineTo(-hw, hl * 0.7);
      ctx.lineTo(-hw, -hl * 0.35);
      ctx.closePath();
      ctx.fill();

      // Deck line
      ctx.fillStyle = 'rgba(255,255,255,0.05)';
      ctx.fillRect(-hw * 0.7, -hl * 0.15, hw * 1.4, hl * 0.5);

      if (ship.type === 'battleship') {
        // Bridge
        ctx.fillStyle = 'rgba(200,200,210,0.25)';
        ctx.fillRect(-hw * 0.4, -hl * 0.1, hw * 0.8, hl * 0.3);
        // Turrets
        ctx.fillStyle = '#555a60';
        ctx.beginPath();
        ctx.arc(0, -hl * 0.35, hw * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(0, hl * 0.2, hw * 0.3, 0, Math.PI * 2);
        ctx.fill();
        // Gun barrels
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -hl * 0.35);
        ctx.lineTo(0, -hl * 0.6);
        ctx.stroke();
      } else if (ship.type === 'cruiser') {
        ctx.fillStyle = 'rgba(200,200,210,0.2)';
        ctx.fillRect(-hw * 0.35, -hl * 0.05, hw * 0.7, hl * 0.25);
        ctx.fillStyle = '#5a6068';
        ctx.beginPath();
        ctx.arc(0, -hl * 0.22, hw * 0.28, 0, Math.PI * 2);
        ctx.fill();
      } else if (ship.type === 'destroyer') {
        ctx.fillStyle = 'rgba(200,200,210,0.18)';
        ctx.fillRect(-hw * 0.3, 0, hw * 0.6, hl * 0.2);
        ctx.fillStyle = '#6a6a70';
        ctx.beginPath();
        ctx.arc(0, -hl * 0.15, hw * 0.22, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Transport
        ctx.fillStyle = 'rgba(200,200,210,0.15)';
        ctx.fillRect(-hw * 0.4, -hl * 0.05, hw * 0.8, hl * 0.35);
      }

      // AA indicator: small orange dot if ship has AA
      if (ship.aaRate > 0) {
        ctx.fillStyle = 'rgba(255,150,50,0.5)';
        ctx.beginPath();
        ctx.arc(0, -hl * 0.1, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawBullet(b) {
      ctx.fillStyle = '#ffd740';
      ctx.fillRect(b.x - 1, b.y, 2, 6);
      // Slight trail
      ctx.fillStyle = 'rgba(255,215,64,0.3)';
      ctx.fillRect(b.x - 0.5, b.y + 6, 1, 4);
    }

    function drawBomb(bomb) {
      if (bomb.exploded) return;
      const progress = bomb.frame / bomb.totalFrames;
      const currentY = bomb.startY + (bomb.targetY - bomb.startY) * progress;

      // Growing shadow/target at impact point
      const shadowSize = 6 + progress * 28;
      ctx.fillStyle = `rgba(0,0,0,${0.08 + progress * 0.15})`;
      ctx.beginPath();
      ctx.ellipse(bomb.x, bomb.targetY, shadowSize, shadowSize * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Target reticle
      ctx.strokeStyle = `rgba(255,60,60,${0.2 + progress * 0.6})`;
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.arc(bomb.x, bomb.targetY, shadowSize + 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);

      // Crosshairs at target
      const cr = shadowSize + 8;
      ctx.strokeStyle = `rgba(255,60,60,${0.15 + progress * 0.4})`;
      ctx.beginPath();
      ctx.moveTo(bomb.x - cr, bomb.targetY);
      ctx.lineTo(bomb.x - cr * 0.3, bomb.targetY);
      ctx.moveTo(bomb.x + cr * 0.3, bomb.targetY);
      ctx.lineTo(bomb.x + cr, bomb.targetY);
      ctx.moveTo(bomb.x, bomb.targetY - cr);
      ctx.lineTo(bomb.x, bomb.targetY - cr * 0.3);
      ctx.moveTo(bomb.x, bomb.targetY + cr * 0.3);
      ctx.lineTo(bomb.x, bomb.targetY + cr);
      ctx.stroke();

      // Falling bomb dot (shrinks as it "falls away")
      const dotSize = 3 - progress * 1.5;
      if (dotSize > 0.5) {
        ctx.fillStyle = '#444';
        ctx.beginPath();
        ctx.arc(bomb.x, currentY, dotSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawAAShot(aa) {
      // Bright tracer
      ctx.fillStyle = 'rgba(255,120,30,0.8)';
      ctx.beginPath();
      ctx.arc(aa.x, aa.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
      // Glow
      ctx.fillStyle = 'rgba(255,80,20,0.2)';
      ctx.beginPath();
      ctx.arc(aa.x, aa.y, 5, 0, Math.PI * 2);
      ctx.fill();
      // Trail
      ctx.strokeStyle = 'rgba(255,120,30,0.15)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(aa.x, aa.y);
      ctx.lineTo(aa.x - aa.dx * 4, aa.y - aa.dy * 4);
      ctx.stroke();
    }

    function drawExplosion(exp) {
      const progress = exp.frame / exp.duration;
      const alpha = 1 - progress;
      const r = exp.size * (0.5 + progress * 1.5);

      if (exp.type === 'ship') {
        // Big fiery explosion
        ctx.fillStyle = `rgba(255,160,30,${alpha * 0.6})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, r, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = `rgba(255,255,120,${alpha * 0.4})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, r * 0.5, 0, Math.PI * 2);
        ctx.fill();

        // Outer ring
        ctx.strokeStyle = `rgba(255,100,20,${alpha * 0.4})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, r * 1.3, 0, Math.PI * 2);
        ctx.stroke();

        // Smoke
        ctx.fillStyle = `rgba(60,60,60,${alpha * 0.5})`;
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI * 2 / 6) * i + progress * 2;
          const d = r * progress * 1.2;
          ctx.beginPath();
          ctx.arc(exp.x + Math.cos(a) * d, exp.y + Math.sin(a) * d, 3 + progress * 4, 0, Math.PI * 2);
          ctx.fill();
        }

        // Water column
        if (progress < 0.6) {
          const colH = progress * 50;
          ctx.fillStyle = `rgba(180,220,255,${(0.6 - progress) * 0.5})`;
          ctx.beginPath();
          ctx.moveTo(exp.x - 6, exp.y);
          ctx.lineTo(exp.x - 2, exp.y - colH);
          ctx.lineTo(exp.x + 2, exp.y - colH);
          ctx.lineTo(exp.x + 6, exp.y);
          ctx.closePath();
          ctx.fill();
        }
      } else if (exp.type === 'plane') {
        ctx.fillStyle = `rgba(255,140,30,${alpha * 0.7})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = `rgba(255,255,150,${alpha * 0.4})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, r * 0.4, 0, Math.PI * 2);
        ctx.fill();
      } else {
        // Water splash (bomb miss)
        ctx.fillStyle = `rgba(180,220,255,${alpha * 0.5})`;
        ctx.beginPath();
        ctx.arc(exp.x, exp.y, r * 0.7, 0, Math.PI * 2);
        ctx.fill();
        const colH = progress * 30;
        ctx.fillStyle = `rgba(200,230,255,${alpha * 0.4})`;
        ctx.beginPath();
        ctx.moveTo(exp.x - 4, exp.y);
        ctx.lineTo(exp.x - 1, exp.y - colH);
        ctx.lineTo(exp.x + 1, exp.y - colH);
        ctx.lineTo(exp.x + 4, exp.y);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawOverlay(text, subtext) {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, H / 2 - 55, W, 110);

      ctx.fillStyle = '#4fc3f7';
      ctx.font = 'bold 36px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(text, W / 2, H / 2 - 5);

      ctx.fillStyle = '#6a8fa8';
      ctx.font = '16px Courier New';
      ctx.fillText(subtext, W / 2, H / 2 + 28);
      ctx.textAlign = 'left';
    }

    function updateHUD() {
      document.getElementById('score').textContent = score;
      document.getElementById('guns').textContent = infiniteGuns ? '\u221E' : gunAmmo;
      document.getElementById('bombs').textContent = infiniteBombs ? '\u221E' : bombAmmo;
      const hearts = '\u2665'.repeat(Math.max(0, player.lives));
      document.getElementById('lives').textContent = hearts || '--';
      document.getElementById('level').textContent = level;
      document.getElementById('hiscore').textContent = hiScore || 0;
    }

    // --- Update ---

    function update() {
      scrollOffset += 1.5;

      if (gameState !== 'playing') return;

      // Cooldowns
      if (gunCooldown > 0) gunCooldown--;
      if (bombCooldown > 0) bombCooldown--;
      if (muzzleFlash > 0) muzzleFlash--;
      if (player.invincible > 0) player.invincible--;
      if (screenShake > 0) { screenShake *= 0.88; if (screenShake < 0.3) screenShake = 0; }

      // Player movement
      if (keys['ArrowLeft'] || keys['a']) player.x -= PLAYER_SPEED;
      if (keys['ArrowRight'] || keys['d']) player.x += PLAYER_SPEED;
      if (keys['ArrowUp'] || keys['w']) player.y -= PLAYER_SPEED;
      if (keys['ArrowDown'] || keys['s']) player.y += PLAYER_SPEED;
      player.x = Math.max(30, Math.min(W - 30, player.x));
      player.y = Math.max(30, Math.min(H - 30, player.y));

      // Auto-fire gun when holding space
      if (keys[' ']) fireGun();

      // Update bullets
      for (const b of bullets) b.y += b.dy;
      bullets = bullets.filter(b => b.y > -10);

      // Update bombs
      for (const bomb of bombs) {
        bomb.frame++;
        if (bomb.frame >= bomb.totalFrames && !bomb.exploded) {
          bomb.exploded = true;
          let hitShip = false;
          for (const ship of enemyShips) {
            if (!ship.alive) continue;
            if (Math.abs(bomb.x - ship.x) < ship.beam / 2 + BOMB_BLAST_R &&
                Math.abs(bomb.targetY - ship.y) < ship.len / 2 + BOMB_BLAST_R) {
              destroyShip(ship);
              hitShip = true;
            }
          }
          explosions.push({
            x: bomb.x, y: bomb.targetY,
            frame: 0, duration: hitShip ? 55 : 25,
            size: hitShip ? 30 : 14,
            type: hitShip ? 'ship' : 'water'
          });
          screenShake = hitShip ? 10 : 3;
        }
      }
      bombs = bombs.filter(b => b.frame < b.totalFrames + 30);

      // Update ships
      for (const ship of enemyShips) {
        if (!ship.alive) continue;
        ship.y += ship.speed;
        ship.x += ship.hSpeed;
        if (ship.x < ship.beam + 20 || ship.x > W - ship.beam - 20) ship.hSpeed *= -1;
        if (ship.y > H + ship.len) ship.alive = false;

        // AA fire
        if (ship.aaRate > 0) {
          ship.aaTimer--;
          if (ship.aaTimer <= 0) {
            ship.aaTimer = ship.aaRate + Math.floor(Math.random() * 20);
            fireAA(ship);
          }
        }
      }

      // Update enemy planes
      for (const plane of enemyPlanes) {
        if (!plane.alive) continue;
        plane.x += plane.sx;
        plane.y += plane.sy;
        if (plane.x < -50 || plane.x > W + 50 || plane.y < -50 || plane.y > H + 50) {
          plane.alive = false;
        }
      }

      // Update AA shots
      for (const aa of aaShots) {
        aa.x += aa.dx;
        aa.y += aa.dy;
        aa.life--;
      }
      aaShots = aaShots.filter(a => a.life > 0);

      // Update explosions
      for (const exp of explosions) exp.frame++;
      explosions = explosions.filter(e => e.frame < e.duration);

      // --- Collisions ---

      // Bullets vs enemy planes
      for (const b of bullets) {
        for (const plane of enemyPlanes) {
          if (!plane.alive) continue;
          if (Math.abs(b.x - plane.x) < 14 && Math.abs(b.y - plane.y) < 14) {
            plane.alive = false;
            b.y = -100;
            score += 100;
            explosions.push({ x: plane.x, y: plane.y, frame: 0, duration: 25, size: 14, type: 'plane' });
          }
        }
      }

      // AA vs player
      if (player.invincible <= 0) {
        for (const aa of aaShots) {
          if (Math.abs(aa.x - player.x) < 14 && Math.abs(aa.y - player.y) < 18) {
            hitPlayer();
            aa.life = 0;
            break;
          }
        }
      }

      // Enemy planes vs player
      if (player.invincible <= 0) {
        for (const plane of enemyPlanes) {
          if (!plane.alive) continue;
          if (Math.abs(plane.x - player.x) < 22 && Math.abs(plane.y - player.y) < 22) {
            plane.alive = false;
            hitPlayer();
            explosions.push({
              x: (plane.x + player.x) / 2, y: (plane.y + player.y) / 2,
              frame: 0, duration: 30, size: 18, type: 'plane'
            });
            break;
          }
        }
      }

      // --- Spawning ---

      if (shipsSpawned < shipsToSpawn) {
        shipSpawnTimer--;
        if (shipSpawnTimer <= 0) {
          spawnShip();
          shipsSpawned++;
          shipSpawnTimer = Math.max(40, 80 + Math.floor(Math.random() * 50) - level * 5);
        }
      }

      planeSpawnTimer--;
      if (planeSpawnTimer <= 0) {
        spawnEnemyPlane();
        planeSpawnTimer = Math.max(60, 140 + Math.floor(Math.random() * 80) - level * 8);
      }

      // --- Level complete? ---
      const aliveShips = enemyShips.filter(s => s.alive);
      if (shipsSpawned >= shipsToSpawn && aliveShips.length === 0) {
        score += level * 200;
        gameState = 'levelclear';
        setTimeout(() => {
          level++;
          gameState = 'playing';
          startLevel();
        }, 2500);
      }

      // --- Ammo check ---
      const hasGuns = infiniteGuns || gunAmmo > 0;
      const hasBombs = infiniteBombs || bombAmmo > 0;
      const hasProjectiles = bullets.length > 0 || bombs.some(b => !b.exploded);
      if (!hasGuns && !hasBombs && !hasProjectiles) {
        gameState = 'gameover';
        gameOverReason = 'OUT OF AMMUNITION';
        if (score > (hiScore || 0)) hiScore = score;
      }

      updateHUD();
    }

    // --- Draw ---

    function draw() {
      ctx.save();
      if (screenShake > 0) {
        ctx.translate(
          (Math.random() - 0.5) * screenShake * 2,
          (Math.random() - 0.5) * screenShake * 2
        );
      }

      drawWater();

      // Draw bomb shadows first (below everything)
      for (const bomb of bombs) drawBomb(bomb);

      // Ships
      for (const ship of enemyShips) drawShip(ship);

      // AA shots
      for (const aa of aaShots) drawAAShot(aa);

      // Bullets
      for (const b of bullets) drawBullet(b);

      // Explosions
      for (const exp of explosions) drawExplosion(exp);

      // Enemy planes
      for (const plane of enemyPlanes) drawEnemyPlane(plane);

      // Player
      drawPlayerPlane();

      ctx.restore();

      // Overlays (outside shake)
      if (gameState === 'levelclear') {
        drawOverlay('SECTOR CLEAR!', `Ships destroyed: ${shipsDestroyed}/${shipsToSpawn} — Advancing to sector ${level + 1}...`);
      } else if (gameState === 'gameover') {
        drawOverlay('GAME OVER', `${gameOverReason} — Press R to restart`);
      }

      // Damage flash
      if (player.invincible > INVINCIBLE_FRAMES - 6) {
        ctx.fillStyle = `rgba(255,0,0,${(player.invincible - (INVINCIBLE_FRAMES - 6)) / 12})`;
        ctx.fillRect(0, 0, W, H);
      }
    }

    function gameLoop() {
      update();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // --- Input ---

    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;

      if (e.key === ' ') e.preventDefault();
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        e.preventDefault();
      }

      if ((e.key === 'b' || e.key === 'B') && gameState === 'playing') {
        dropBomb();
      }
      if ((e.key === 'r' || e.key === 'R') && gameState === 'gameover') {
        init();
      }
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    // --- Settings ---

    document.getElementById('settingsBtn').addEventListener('click', () => {
      document.getElementById('settingsOverlay').classList.add('open');
    });
    document.getElementById('settingsClose').addEventListener('click', () => {
      document.getElementById('settingsOverlay').classList.remove('open');
      applySettings();
      init();
    });
    document.getElementById('settingsOverlay').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) {
        document.getElementById('settingsOverlay').classList.remove('open');
        applySettings();
        init();
      }
    });

    // --- Start ---
    hiScore = 0;
    init();
    gameLoop();
  </script>
</body>
</html>
